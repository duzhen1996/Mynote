# 实用数据库

[TOC]


## 1、Linux的使用

默认虚拟机账户root，密码oracle。

还有一个用户叫做oracle，密码也是oracle。

### 1.1、linux文件

所有普通用户的子目录放在home里面，但是管理员的主目录在根目录下，叫做root。

/tmp是临时目录

/etc是存放配置信息的

/var服务器运行产生的日志

/sbin管理员执行的命令

/bin是普通用户可执行的命令

/dev设备文件

### 1.2、Linux命令

#### 1.2.0、一些简单的常用命令

date：查看时间

passwd： 修改用户名

ls

file：查看文件的类型

history：查看历史命令

pwd：查看当前目录

cd：改变工作目录

#### 1.2.1、查看文本文件内容

head -10 文件名	查看前几行（10）文件的内容

tail -10 文件名	查看文件的最后几行（10）

cat 文件名	查看小文件

more/less 文件名	可以上下翻

wc 文件名	依次显示多少行、多少个单词、多少个字符。

ls -l 每一项的意义：

> **比如显示这么一行：**
>
> **-rwxr-x--- root     root        10700 1970-01-01 00:00 init.rc**
>
> **1. 权限的问题**
>
> **总共有十个杠，“----------”**
>
> **第一条杠，代表文件类型，可以取值：**
>
> **   - 普通文件**
>
> **   b 块特殊文件**
>
> **   c 字符特殊文件**
>
> **   d 目录**
>
> **   l 连接**
>
> **   p 命名管道（FIFO）**
>
> **后面九条杠，三条一组，可以是rwxrwxrwx，**
>
> **这代表按顺序所有者、组、其他用户的访问权限均为可读可写可执行。**
>
> **如果其中哪个位置还是杠，就是说这个位置没有相应的权限。**
>
> **比如，如果是“-rwxr--r--”，代表：这是个普通文件（第一条杠），所有者具有读、写、执行权限；组具有只读权限；其他用户具有只读权限。**
>
> **2. 第二个字段，表示所有者的登录名；（据说在他前面还有个“连接数”，我这怎么没有？）**
>
> ** 第三个字段，表示所有者的组名；**
>
> ** 第四个字段，文件大小，字节为单位**
>
> ** 五六（七）字段，最近修改的日期时间**
>
> ** 最后一个字段，文件名**

ls -R 	递归查看目录中的内容

#### 1.2.2、tab键补全

单击tab、双击tab

#### 1.2.3、建立文件

Linux文件名是区分大小写的

touch 文件名	如果该文件已存在，那么这个文件的时间会被刷新。

文件名以“.”开头，那就是隐藏文件

mkdir 目录名	创建目录，使用rmdir就可以移除

#### 1.2.4、拷贝命令

cp 数个文件名，系统将最后一个参数作为目的地，第一个参数作为源文件。

cp -r 数个目录名，可以将目录以及目录下的内容进行递归拷贝

#### 1.2.5、移动

mv 后面跟着两个文件名，如果在相同文件下相当于改名，如果在不同目录下就是移动。

mv移动一整个文件夹不需要加-r。

mv这个命令有一个坑，如果目标目录存在，那么就会移动到目标目录下，如果目标目录不存在，那就实际上是一个改名的操作。

#### 1.2.6、删除

rm 使用-r可以对一个目录进行递归删除。

#### 1.2.7、帮助

—help

-h

使用man+其他命令就可以查看这个产品的完整手册。

pinfo是一个更加完整的手册。



### 1.3、Linux账户
useradd 用户名    创建，-g设定主要组，-G设定普通组，如果没有这两个参数，主要组名就是用户名
id 用户名    查看一个账户，其中得到的gid是主要组
usermod用户名    修改，使用-G参数绑定组，-G参数以及参数的内容要放在用户名前面
userdel 删除    加上-r参数
groupadd 组   
passwd 用户名    为用户设置一个密码
/home/user/.bash_profile    用户的配置
gedit 文件名    编辑一个文件
su - 用户名    更改用户
### 1.4、Linux权限
读 r    4
写 w    2
执行 x    1
2-4位拥有者权限，5-7拥有者组，8-10其他的人对这个文件的权限。第一位不知道是干嘛用的
chmod 数字    修改权限使用-r参数递归修改。
### 1.5、Linux进程
ps -ef|grep 关键字
kill加线程号    关闭线程
service 服务名 start/statue/stop
### 1.6、Linux软件包安装
rpm+软件包
eject 弹出光盘
### 1.7、其他

##2、数据库Oracle DB
###2.1、数据库的开启
使用数据库，必须使用Oracle用户。使用```lsnrctl start```启动监听器。
![](https://ww2.sinaimg.cn/large/006tNc79ly1fd1bjqde7vj313m0za41x.jpg)
在后面使用stop、start、statue可以关闭和查看状态
然后输入```sqlplus （用户名）/ as sysdba```来操作数据库
然后在sql终端中输入```start up```，打开数据库.
数据库管理员的账号叫做sys，使用show user可以查看当前用户。system是一个权限很大的用户。
###2.2、SQLdeveloper
这个是一个图像化管理sql的软件，在使用之前要使用```xhost + ```命令来关闭访问控制。得要的效果：
![](https://ww3.sinaimg.cn/large/006tNc79ly1fd1c9z0qs4j31kw0y0410.jpg)
sid要改成orcl才可以登录成功。
###2.3、Oracle的体系结构
数据库服务器=Instance+Database
Instance=Process+Memory
Database=File（Disk）

###2.4、数据库的文件
数据库的文件：
- 数据文件 ```select name from v$datafile```
- 日志文件 ```select member from v$logfile```
- 控制文件 ```select name from v$controlfile```
- 参数文件 ```/u01/app/oracle/product/11.2.0/dbhome_1/dbs/spfileorc.ora```
- 口令文件 ```/u01/app/oracle/product/11.2.0/dbhome_1/dbs/orapworcl```
- 跟踪文件 ```/u01/app/oracle/product/11.2.0/dbhome_1/dbs/trace```
- 预警文件 ```/u01/app/oracle/product/11.2.0/dbhome_1/dbs/alert_orcl.log```

###2.5、数据库的开启与关闭
startup的时候这个文件会被系统搜寻到。首先被找到的是参数文件（ORACLE instance started），然后是控制文件（Database mounted），最后是数据+日志文件（Database opened）。
shutdown normal是关闭命令。问题是如果还有用户在这个服务器上，那么就不会关闭，知道所有用户全部断开连接。
shutdown transactional催促全部关闭，用户commit 之后才会关闭。
> 注：insert以后commit之前是锁表的状态，其他事务无法对该表进行操作
> shutdown immediate
> shutdown abort（强制断电）

###2.6、startup的三个阶段
start nomount：实例启动（进程、内存）
Oracle至少有6个进程。最大的进程数依赖于操作系统。
Database mount：数据库装载
Database opened：数据库打开
Oracle服务器=实例+数据库

###2.7、实例的启动参数
实例的启动主要控制参数文件。参数文件存放在固定的位置，文件名固定。
这个参数文件不能用打开文本文件的方式打开它。而已使用strings命令看到里面的内容。里面是数据库的配置。
我们可以在帮助文档文档中看到数据库的配置相关内容，帮助文档实际上是一个本地的html。在Reference里面查看第一部分内容“初始化参数”。
####2.7.1、参数---dbname
这个参数是这个数据库的名字，创建数据库的时候使用，这个参数不能修改，只能在创建数据库的时候指定。
####2.7.2、参数---dbdomain
这个参数是这个数据库的域名
####2.7.3、参数---processes
这个参数也是不能改的。不能改的参数都是在第一次安装Oracle的时候被安装的，是不能改的。
####2.7.4、参数---JavaPoolSize
这个参数是一个和内存相关的参数，是给Java虚拟机用的。默认值是0，可以直接改。
####2.7.5、参数查看
使用show parameter 可以看到立即生效的值
```shell
SQL> startup
ORACLE instance started.

Total System Global Area  849530880 bytes
Fixed Size	    1339824 bytes
Variable Size	  507514448 bytes
Database Buffers	  335544320 bytes
Redo Buffers	    5132288 bytes
Database mounted.
Database opened.
SQL> show parameter java_pool_size

NAME	    TYPE	VALUE
------------------------------------ ----------- ------------------------------
java_pool_size	    big integer 0
SQL> 
```

####2.7.6、参数修改
```shell
SQL> alter system set java_pool_size=20M;

System altered.
```
另外可以增加scope=memory参数，加了这个参数，参数文件中的值就不会修改。
另外增加scope=spfile参数，可以仅修改参数文件，下次启动生效。如果什么都不加都是都改。
此外使用scope=spfile可以强制更改一些不让修改的参数。
###2.8、网络配置
####2.8.1服务器端与客户端配置
lsnrctl start，启动监听器，调用进程tnslnr，使用listener.ora来配置。 
listener.ora：监听器的名字：Listener。
主机名： server1.example.coom 协议TCP 端口 1521
oracle服务器服务名 orcl.example.coom （自动注册或者手动填写），只有在端口是1521的时候才可以自动注册。
客户端使用sqlplus 用户名/密码 这是一种本地连接的方式
sqlplus 用户名/密码@监听器的主机名(或者IP地址):端口/服务器服务名
####2.8.2、监听器配置
新建额外的监听器只要在listener.ora这个文件中填写新的内容就好了。
我们也可以使用netmgr来制作监听器。
![](https://ww3.sinaimg.cn/large/006tKfTcly1fd68vkd518j31ks13wwgq.jpg)
![](https://ww1.sinaimg.cn/large/006tKfTcly1fd68ta3c5nj316q11idi2.jpg)
注意虚拟机的分辨率，分辨率。
####2.8.3、客户端连接标识符
修改配置文件，在客户端的同一个目录下tnsnames.ora。也可以用netmgr编辑。
![](https://ww2.sinaimg.cn/large/006tKfTcly1fd698gbtejj316o108wgm.jpg)
这样子我们就可以直接使用c1来代替@后面那一大串了：
```shell
[oracle@server1 ~]$ sqlplus hr/hr@c1

SQL*Plus: Release 11.2.0.1.0 Production on Wed Mar 1 00:20:11 2017

Copyright (c) 1982, 2009, Oracle.  All rights reserved.


Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

SQL> 
```
###2.9、数据库的使用
####2.9.1、数据文件
一个表空间就是一个数据文件
数据文件的位置/u01/app/oracle/oradata/orcl/。在这个目录下。
####2.9.2、创建表空间
我们可以使用`create tablespace`和`select tablespace_name from dba_data_files;`这两个命令创建和获取表空间。
注意使用管理员登录。

```shell
[root@server1 ~]# su - oracle
[oracle@server1 ~]$ sqlplus / as sysdba

SQL*Plus: Release 11.2.0.1.0 Production on Wed Mar 1 00:41:56 2017

Copyright (c) 1982, 2009, Oracle.  All rights reserved.


Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options
SQL> create tablespace tbs1 datafile '/u01/app/oracle/oradata/orcl/tbs1.dbf' size 50M autoextend on next 10M maxsize 30G;
//因为表空间不能为空，需要在创建的时候往里面放一个文件。
Tablespace created.
SQL> select tablespace_name from dba_data_files;

TABLESPACE_NAME
------------------------------
USERS
UNDOTBS1
SYSAUX
SYSTEM
EXAMPLE
TBS1

6 rows selected.

SQL> 
```
####2.9.3、向已有的表空间添加数据文件
这里要注意大小写。
```shell
SQL> alter tablespace tbs1 add datafile '/u01/app/oracle/oradata/orcl/tbs1_2.dbf' size 50M autoextend                       
on next 20M maxsize unlimited;

Tablespace altered.

SQL> select file_name from dba_data_files where tablespace_name='TBS1';
//在查看表空间中的文件的时候需要大写，虽然前面添加数据文件的时候是tbs1小写

FILE_NAME
--------------------------------------------------------------------------------
/u01/app/oracle/oradata/orcl/tbs1.dbf
/u01/app/oracle/oradata/orcl/tbs1_2.dbf

SQL> 
```
上面这个是添加一个文件。
我们也可以在一个表空间中同时添加两个文件。
```shell
SQL> create tablespace tbs2 datafile '/u01/app/oracle/oradata/orcl/tbs2_1.dbf' size 20M autoextend on next 10M maxsize               
 20G,'/u01/app/oracle/oradata/orcl/tbs2_2.dbf' size 20M autoextend on next 10M maxsize 20G;
//其实用一个逗号隔开两个文件即可
Tablespace created.

SQL> select file_name from dba_data_files where tablespace_name='TBS2';    

FILE_NAME
--------------------------------------------------------------------------------
/u01/app/oracle/oradata/orcl/tbs2_1.dbf
/u01/app/oracle/oradata/orcl/tbs2_2.dbf

SQL> 
```
####2.9.4、删除表空间
```shell
SQL> drop tablespace tbs2;

Tablespace dropped.

SQL> create table test1(id number) tablespace tbs1;

Table created.

SQL> insert into test1 values(100);

1 row created.

SQL> commit;

Commit complete.

SQL> drop tablespace tbs1;
drop tablespace tbs1
*
ERROR at line 1:
ORA-01549: tablespace not empty, use INCLUDING CONTENTS option


SQL> drop tablespace tbs1 including contents;

Tablespace dropped.

SQL> 
```
我们可以看到如果表空间里面已经有其他的东西，那么就要加上`including contents`来删除表空间，这种方式数据文件中的内容会被删除，
但是删除了表空间之后数据文件并不会被随之删除，我们需要在对应的目录下删除数据文件。
如果我们删除了表空间之后还要删除数据文件，那么使用参数`including contents and datafiles`。

##3、Oracle安装
###3.1、准备虚拟机
我们将Oracle安装到虚拟机中。我们至少准备2G的内存，以及一个“仅主机模式”的网络。并且我们会挂载一个光盘。
![](https://ww4.sinaimg.cn/large/006tNbRwly1fd9cnumw8tj30mc0s6myg.jpg)
![](https://ww1.sinaimg.cn/large/006tNbRwly1fd9coeb6l0j309e05sdft.jpg)
###3.2、安装操作系统
Oracle Enterprise Linux，这个是和Oracle数据库最搭配的Linux。
这里Skip，不检测光盘。
![](https://ww4.sinaimg.cn/large/006tNbRwly1fd9cw4h1vnj313q0m60tr.jpg)
然后一路yes、ok。语言、键盘、分区使用默认。
ip地址与子网掩码，已经主机名要去定制。
然后网络手动定制：
![](https://ww3.sinaimg.cn/large/006tNbRwly1fd9d53jod7j31880x2myh.jpg)
去除UTC设置。
软件安装选择Customize now。选中所有Develop选项，除了KDE。
最后就进入安装，点击Reboot启动。
启动之后输入硬盘密码，然后进入网络设置。我们将Firewall以及SELinux（安全）disable。然后密码等内容一概不设值，一路向下，完成初始设置。
###3.3、安装Oracle数据库
图像界面的安装至少需要1024的分辨率。
安装需求和步骤看帮助文档。
####3.3.1、建立账号
我们通过history命令重现了当时的命令。
```shell
    2  groupadd oinstall
    3  groupadd dba
    4  groupadd oper
    5  useradd -g oinstall -G dba,oper oracle
    6  passwd oracle
```
####3.3.2、建立安装目录
```shell
[root@dbs33 ~]# mkdir -p /u01/app/oracle
[root@dbs33 ~]# chown -R oracle.oinstall /u01
[root@dbs33 ~]# chmod -R 775 /u01
```
####3.3.3、设置oracle账户的环境变量
我们需要TMP、TMPDIR、ORACLE_BASE、ORACLE_HOME、ORACLE_SID、PATH，这么几个环境变量，通过使用export关键字。
这些东西需要使用gedit去编辑/home/oracle/.bash_profile
在环境变量中添加下列东西。
```vim
umask 022
export TMP=/tmp
export TMPDIR=/tmp
export ORACLE_BASE=/u01/app/oracle
export ORACLE_HOME=/u01/app/oracle/product/11.2.0/dbhome_1
export ORACLE_SID=orcl
export PATH=.:$ORACLE_HOME/bin:$PATHs
```
####3.3.4、安装（安装文件 在otn.oracle.com下）
我们首先在虚拟机中连接虚拟光驱，然后在media目录下找到光驱文件并复制出来。
```shell
[root@dbs33 ~]# eject
[root@dbs33 ~]# ls /media/
20111022_153821
[root@dbs33 ~]# cp -r /media/20111022_153821/ /tmp
```
在root账号下面运行xhost +，这样子可以在普通用户打开图形界面，然后打开安装程序。
```shell
[root@dbs33 ~]# xhost +
access control disabled, clients can connect from any host
[root@dbs33 ~]# su - oracle
[oracle@dbs33 ~]$ cd /tmp/20111022_153821/stage//11.2.0/database/Disk1/
[oracle@dbs33 Disk1]$ ls
doc  install  response  rpm  runInstaller  sshsetup  stage  welcome.html
[oracle@dbs33 Disk1]$ ./runInstaller 
Starting Oracle Universal Installer...

Checking Temp space: must be greater than 80 MB.   Actual 8198 MB    Passed
Checking swap space: must be greater than 150 MB.   Actual 4031 MB    Passed
Checking monitor: must be configured to display at least 256 colors.    Actual 16777216    Passed
Preparing to launch Oracle Universal Installer from /tmp/OraInstall2017-03-03_06-11-27PM. Please wait ...[oracle@dbs33 Disk1]$ 
```
在图像界面中，我们不输入用户名和指令。
然后就进入第二个页面：
![](https://ww2.sinaimg.cn/large/006tNbRwly1fd9fph82fhj30ro0dygm2.jpg)
第一个选项：安装软件并且创建数据库。我们要将这两个过程分开来。所以我们选择第二个选项，即仅安装软件。
然后我们选择“单节点数据库”：
![](https://ww3.sinaimg.cn/large/006tNbRwly1fd9ftfqalcj30ua0cmmxm.jpg)
语言我们可以添加一个简体中文。默认English
版本我们选择企业版。
安装路径实际上基于我们之前的环境变量进行自动的填充：
![](https://ww3.sinaimg.cn/large/006tNbRwly1fd9fwqtcgtj317e0hywfx.jpg)
然后我们一路下一步。
然后我们就可以看到一大堆错误。
![](https://ww2.sinaimg.cn/large/006tNbRwly1fd9g3lag2nj31760qygok.jpg)
我们可以直接修复。点击“fixed and check again”
按照程序的提示，我们需要在管理员下执行一些脚本：
```shell
[root@dbs33 tmp]# /tmp/CVU_11.2.0.1.0_oracle/runfixup.sh
Response file being used is :/tmp/CVU_11.2.0.1.0_oracle/fixup.response
Enable file being used is :/tmp/CVU_11.2.0.1.0_oracle/fixup.enable
Log file location: /tmp/CVU_11.2.0.1.0_oracle/orarun.log
Setting Kernel Parameters...
kernel.sem = 250 32000 100 128
fs.file-max = 6815744
net.ipv4.ip_local_port_range = 9000 65500
net.core.rmem_default = 262144
net.core.wmem_default = 262144
net.core.rmem_max = 4194304
net.core.wmem_max = 1048576
fs.aio-max-nr = 1048576
uid=500(oracle) gid=500(oinstall) groups=500(oinstall),501(dba),502(oper)
[root@dbs33 tmp]# 
```
然后回到窗口点击“OK”我们就发现错误变少很多。
![](https://ww4.sinaimg.cn/large/006tNbRwly1fd9g8a8t3dj30w206u0t2.jpg)
然后我们打开Linux光盘下安装一些软件（在eject之后我们光盘就断开连接了，我们需要在虚拟机的光驱中选中新的光驱，然后重新连接）：
```shell
[root@dbs33 /]# eject 
[root@dbs33 /]# ls /media/
Enterprise Linux dvd 20090908
[root@dbs33 /]# cd /media/Enterprise\ Linux\ dvd\ 20090908/
[root@dbs33 Enterprise Linux dvd 20090908]# ls
blafdoc.css     eula.py    README-en.html         Server
Cluster         GPL        RELEASE-NOTES-en       supportinfo
ClusterStorage  images     RELEASE-NOTES-en.html  TRANS.TBL
EULA            isolinux   RPM-GPG-KEY            VT
eula.en_US      README-en  RPM-GPG-KEY-oracle
[root@dbs33 Enterprise Linux dvd 20090908]# cd Server/
[root@dbs33 Server]# pwd
/media/Enterprise Linux dvd 20090908/Server
[root@dbs33 Server]# rpm -ivh sysstat-7.0.2-3.el5.i386.rpm libaio-devel-0.3.106-3.2.i386.rpm unixODBC-2.2.11-7.1.i386.rpm unixODBC-devel-2.2.11-7.1.i386.rpm 
warning: sysstat-7.0.2-3.el5.i386.rpm: Header V3 DSA signature: NOKEY, key ID 1e5e0159
Preparing...                ########################################### [100%]
   1:unixODBC               ########################################### [ 25%]
   2:sysstat                ########################################### [ 50%]
   3:libaio-devel           ########################################### [ 75%]
   4:unixODBC-devel         ########################################### [100%]
[root@dbs33 Server]# 
```
然后回到软件，点击“check again”。安装程序会直接进入下一步。
在倒数第二步，“Install Project”，安装下列脚本：
```shell
[root@dbs33 ~]# /u01/app/oralnventory/oranstRoot.sh
bash: /u01/app/oralnventory/oranstRoot.sh: No such file or directory
[root@dbs33 ~]# /u01/app/oraInventory/orainstRoot.sh 
Changing permissions of /u01/app/oraInventory.
Adding read,write permissions for group.
Removing read,write,execute permissions for world.

Changing groupname of /u01/app/oraInventory to oinstall.
The execution of the script is complete.
[root@dbs33 ~]# /u01/app/oracle/product/11.2.0/dbhome_1/root.sh 
Running Oracle 11g root.sh script...

The following environment variables are set as:
    ORACLE_OWNER= oracle
    ORACLE_HOME=  /u01/app/oracle/product/11.2.0/dbhome_1

Enter the full pathname of the local bin directory: [/usr/local/bin]: 
   Copying dbhome to /usr/local/bin ...
   Copying oraenv to /usr/local/bin ...
   Copying coraenv to /usr/local/bin ...


Creating /etc/oratab file...
Entries will be added to the /etc/oratab file as needed by
Database Configuration Assistant when a database is created
Finished running generic part of root.sh script.
Now product-specific root actions will be performed.
Finished product-specific root actions.
[root@dbs33 ~]# 
```
###3.4、创建数据库
首先还是要在root账户下执行xhost + 
然后在oracle账户下执行netca创建监听器，然后在图形界面下一路下一步，直到finish。
然后运行程序dbca建库，一路下一步，然后设一下SID与主机名：
![](https://ww3.sinaimg.cn/large/006tNbRwly1fd9hiudve7j30uw092t99.jpg)
然后一路NEXT。
我们为4个账户设置同一个口令：
![](https://ww4.sinaimg.cn/large/006tNbRwly1fd9hkp7mycj30uo0gojsc.jpg)
然后之后全部使用默认。
sample schema也要选中：
![](https://ww3.sinaimg.cn/large/006tNbRwly1fd9hobd72rj31500b8wfj.jpg)
字符集我们也要选中一下。
![](https://ww1.sinaimg.cn/large/006tNbRwly1fd9hpcmcisj30ue0nwq4k.jpg)
然后一路next。
最后finish就好了。

###3.5、验证/安装数据库
1、验证或者打开数据库
这里检查数据库状态
```shell
[oracle@dbs33 ~]$ lsnrctl status

LSNRCTL for Linux: Version 11.2.0.1.0 - Production on 07-MAR-2017 14:12:49

Copyright (c) 1991, 2009, Oracle.  All rights reserved.

Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=dbs33.example.com)(PORT=1521)))
STATUS of the LISTENER
------------------------
Alias                     LISTENER
Version                   TNSLSNR for Linux: Version 11.2.0.1.0 - Production
Start Date                03-MAR-2017 19:14:55
Uptime                    3 days 18 hr. 57 min. 54 sec
Trace Level               off
Security                  ON: Local OS Authentication
SNMP                      OFF
Listener Parameter File   /u01/app/oracle/product/11.2.0/dbhome_1/network/admin/listener.ora
Listener Log File         /u01/app/oracle/diag/tnslsnr/dbs33/listener/alert/log.xml
Listening Endpoints Summary...
  (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=dbs33.example.com)(PORT=1521)))
Services Summary...
Service "orcl.example.com" has 1 instance(s).
  Instance "orcl", status READY, has 1 handler(s) for this service...
Service "orclXDB.example.com" has 1 instance(s).
  Instance "orcl", status READY, has 1 handler(s) for this service...
The command completed successfully
[oracle@dbs33 ~]$ 
```
这里开启数据库
```shell
[oracle@dbs33 ~]$ lsnrctl start

LSNRCTL for Linux: Version 11.2.0.1.0 - Production on 07-MAR-2017 14:14:36

Copyright (c) 1991, 2009, Oracle.  All rights reserved.

TNS-01106: Listener using listener name LISTENER has already been started

```
2、登录数据库服务器
```shell
[oracle@dbs33 ~]$ sqlplus / as sysdba

SQL*Plus: Release 11.2.0.1.0 Production on Tue Mar 7 14:18:26 2017

Copyright (c) 1982, 2009, Oracle.  All rights reserved.


Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

SQL> 

```
我们可以使用一个sql语句检测数据库是否开启。
```shell
SQL> select status from v$instance;

STATUS
------------
OPEN

SQL> 

```
###3.6、oracle Enterprise Manager
```shell
[oracle@dbs33 ~]$ emctl start dbconsole
Oracle Enterprise Manager 11g Database Control Release 11.2.0.1.0 
Copyright (c) 1996, 2009 Oracle Corporation.  All rights reserved.
https://dbs33.example.com:1158/em/console/aboutApplication
 - An instance of Oracle Enterprise Manager 11g Database Control is already running. 
[oracle@dbs33 ~]$ 
```
也可以将start换成status来查看状态，这东西有点像Sql数据库的管理界面，就好像Federal的方式一样。
然后我们在浏览器中输入地址https://dbs33.example.com:1158/em，忽略证书，然后就可以进入一个神奇的界面
![](https://ww1.sinaimg.cn/large/006tKfTcly1fdea2y3y44j31ie0t00wc.jpg)
登录的时候不要选normal

####3.6.1、表空间
我们在server->table space表空间可以使用图像化界面管理表空间。
创建好之后点击：
![](https://ww1.sinaimg.cn/large/006tKfTcly1fdeatp765uj30e2062glj.jpg)
可以得到这个操作的SQL语句。
```SQL
CREATE SMALLFILE TABLESPACE "TBS1_1" DATAFILE '/u01/app/oracle/oradata/orcl/tbs1_1.dbf' SIZE 10M AUTOEXTEND ON NEXT 10M MAXSIZE UNLIMITED , '/u01/app/oracle/oradata/orcl/tbs1_1.dbf' SIZE 10M AUTOEXTEND ON NEXT 10M MAXSIZE UNLIMITED LOGGING EXTENT MANAGEMENT LOCAL SEGMENT SPACE MANAGEMENT AUTO
```
其中`SMALLFILE`代表这个是小文件表空间，存的文件比较多，每个文件容量也比较小。BIGFILE代表大文件表空间，只能存一个文件，每个文件容量大。
其中`LOGGING`代表对于这个表空间的是不是要加入日志用于灾备恢复。
我们可以通过命令查看我们建好的表空间。
```shell
SQL> select name from v$datafile;

NAME
--------------------------------------------------------------------------------
/u01/app/oracle/oradata/orcl/system01.dbf
/u01/app/oracle/oradata/orcl/sysaux01.dbf
/u01/app/oracle/oradata/orcl/undotbs01.dbf
/u01/app/oracle/oradata/orcl/users01.dbf
/u01/app/oracle/oradata/orcl/example01.dbf
/u01/app/oracle/oradata/orcl/tbs1_1.dbf
/u01/app/oracle/oradata/orcl/tbs1_2.dbf

7 rows selected.
```
一个表空间其实就是数据文件。而一个表的对应的是一个段（segment）。
然后我们创建一个表。
```shell
SQL> create table hr.test1 (id number,name varchar2(20)) tablespace users;

Table created.
```
然后我们可以通过命令查看所有的段。
```shell
SQL> select segment_name from dba_segments where segment_name='TEST1' and owner='HR';

SEGMENT_NAME
--------------------------------------------------------------------------------
TEST1
```
我们可以使用for循环插入一大堆数据。
```shell
create table hr.test1 (id number,name varchar2(20)) tablespace users;
begin
for i in 2..100 loop
insert into hr.test1 values(i,'aaa');
end loop;
end;
/
```
数据库的逻辑单位，表空间-段-区（Extents扩展段的单位，8个块）-块（8个字节的空间）。
####3.6.2、用户管理 安全性
创建一个用户：
```shell
SQL> create user jack identified by "jack123";

User created.

SQL> 

```
不过这样子登录不了，我们需要设置一下权限。DCL Data Control Language （grant授权 revoke撤销权限）
```shell
SQL> grant create session to jack;//给予开数据库的权限

Grant succeeded.

SQL> grant create table to jack;//给予创建表

Grant succeeded.

SQL> alter user jack quota 20M on users;//从users表空间分配空间。

User altered.
```
对象权限，让一个用户操作操作其他用户的东西。
```oracle
grand select on hr.employee to jack;
grand insert,update,delete on hr.employee to jack;
grand all on hr.employee to jack;
```
将grant改为revoke，就是撤销权限。
我们在server->user图形化界面中可以使用图形界面配置
![](https://ww1.sinaimg.cn/large/006tKfTcly1fdedeaq7fnj31i40meq5s.jpg)
选择用户 edit->object p->table->add

权限还可以级联付与，对象权限的撤销是级联的。
角色授权。

####3.6.3、概要文件
server->security->profile设置。然后在user里面加入profile。
然后在管理员下执行SQL指令：
```shell
SQL> alter system set resource_limit=true;

System altered.

```
general控制用户资源使用量   
同时需要设置参数  alter system set resource_limit=true;

password控制用户口令安全性
检测口令复杂性的函数  
oracle提供了脚本/u01/app/oracle/product/11.2.0/dbhome_1/rdbms/admin/utlpwdmg.sql
SQL>@?/rdbms/admin/utlpwdmg.sql
创建函数 verify_function_11g

###3.7、数据库的并发性
Oracle 行级锁 
Oracle SELECT 没有锁
Oracle DML(insert delete update) DDL(create alter drop truncate) DCL(grant revoke)
DML(insert delete update) 
		alter user hr identified by "hr";
		alter user hr account unlock;
		alter user hr identified by "hr" account unlock;
表employees   表锁  类型为TM	3   
相关行的    行锁        类型为TX		6
级别 0-6
select sid from v$session where username='HR'; ---查出hr用户的session id
select type,lmode,request from v$lock where sid IN (42,50);
Transaction 1
update employees set salary=salary+100 where employee_id=100;
Transaction 3
update employees set salary=salary+100 where employee_id=101;
类型为TM	   3 (ROW EXCLUSIVE)
类型为TX	  6  (Exclusive)
Transaction 2
drop table employees;  表锁  类型为TM	6

lock table 表名 IN 锁级别 MODE;
lock table employees in row share mode;
3	row excusive
6 exclusive

2 - row-S (SS)					row share
3 - row-X (SX)					row exclusive
4 - share (S)						share
5 - S/Row-X (SSX)			share row exclusive 
6 - exclusive (X				exclusive
解决锁冲突
SQL> select sid from v$lock where block>0;  发现锁定其他会话的SID
SQL> select serial# from v$session where sid=42; 查找序号
SQL> alter system kill session '42,2475' immediate;   kill session

死锁 服务器发现死锁 自动回退
ORA-00060: deadlock detected while waiting for resource

--------
还原数据
oracle 服务器对数据进行修改时 会将旧数据保留一段时间
用于数据撤销/闪回/一致性/.........

1.旧数据存放位置 
有一个类型为UNDO的表空间
create undo tablespace undotbs2 datafile '/u01/app/oracle/oradata/orcl/undotbs2.dbf' size 50M autoextend on next 10M  maxsize 30G;
查看表空间和类型 select tablespace_name,contents from dba_tablespaces;
查看参数  show parameter undo_tablespace
alter system set undo_tablespace=undotbs2;
旧数据存放的时间 （事务量 undo表空间的尺寸）
参数 undo_retention=
SQL> alter system set undo_retention=86400;  --单位是秒

undo表空间的尺寸 
通过指导中心 计算undo空间使用
通过指导中心分析出 尺寸 213M 
alter database datafile '/u01/app/oracle/oradata/orcl/undotbs2.dbf' resize 213M;

###3.8、数据库错误
####3.8.1、语句错误
- 访问不存在的数据
- 没有访问的权限
- 空间不足
- 逻辑错误
####3.8.2、用户进程失败
- 用户异常断开。用户使用的资源仍然在服务器上被分配。
- 一个用户的会话被异常终止。使用`kill session`将用户断开。
####3.8.3、网络错误
- 监听器错误
- 网卡错误
- 网络错误
####3.8.4、使用者错误
- 用户不慎删除或者修改
```shell
SQL> create user user11 identified by user123;

User created.
```
- 用户删除一个表。因为表的删除是立刻提交的。
```shell
SQL>flashback table test1 to before drop;
```
####3.8.5、实例错误
- 电源失效
- 硬件损坏
- 后台进程失效
  删除关键进程，会导致所有的进程全部清空，我们需要重启就好。如果不是关键进程Oracle会立即重启进程。
```shell
[root@dbs33 ~]# ps -ef|grep ora_
oracle     752     1  0 10:31 ?        00:00:00 ora_pmon_orcl
oracle     754     1  0 10:31 ?        00:00:00 ora_vktm_orcl
oracle     758     1  0 10:31 ?        00:00:00 ora_gen0_orcl
oracle     760     1  0 10:31 ?        00:00:00 ora_diag_orcl
oracle     762     1  0 10:31 ?        00:00:00 ora_dbrm_orcl
oracle     764     1  0 10:31 ?        00:00:00 ora_psp0_orcl
oracle     766     1  0 10:31 ?        00:00:03 ora_dia0_orcl
oracle     768     1  0 10:31 ?        00:00:00 ora_mman_orcl
oracle     770     1  0 10:31 ?        00:00:01 ora_dbw0_orcl
oracle     772     1  0 10:31 ?        00:00:01 ora_lgwr_orcl
oracle     774     1  0 10:31 ?        00:00:01 ora_ckpt_orcl
oracle     776     1  0 10:31 ?        00:00:01 ora_smon_orcl
oracle     778     1  0 10:31 ?        00:00:00 ora_reco_orcl
oracle     780     1  0 10:31 ?        00:00:00 ora_mmon_orcl
oracle     782     1  0 10:31 ?        00:00:00 ora_mmnl_orcl
oracle     784     1  0 10:31 ?        00:00:00 ora_d000_orcl
oracle     786     1  0 10:31 ?        00:00:00 ora_s000_orcl
oracle     874     1  0 10:31 ?        00:00:00 ora_qmnc_orcl
oracle     897     1  0 10:31 ?        00:00:00 ora_cjq0_orcl
oracle    1006     1  0 10:31 ?        00:00:00 ora_q000_orcl
oracle    1008     1  0 10:31 ?        00:00:00 ora_q001_orcl
oracle    1014     1  0 10:31 ?        00:00:00 ora_smco_orcl
oracle   28333     1  0 14:42 ?        00:00:00 ora_w000_orcl
oracle   29141     1  0 14:56 ?        00:00:00 ora_j000_orcl
oracle   29143     1  0 14:56 ?        00:00:00 ora_j001_orcl
root     29146 29122  0 14:56 pts/2    00:00:00 grep ora_
[root@dbs33 ~]# kill -9 774
[root@dbs33 ~]# ps -ef|grep ora_
root     29287 29122  0 14:58 pts/2    00:00:00 grep ora_
[root@dbs33 ~]# 
```
- 紧急关机

####3.8.6、存储介质错误
事先备份->介质失效->还原
首先使用文件复用技术
- 日志文件复用
  日志文件存放日志条目-----（数据库的更改过程的相关数据）。
  日志是循环复用的，新的会覆盖老的。
  我们可以增加一个一个副本正价日志文件的可用性。
```shell
alter database add logfile member '/u01/app/oracle/oradata/orcl/redo01_2.log' to group 1;
```
然后我们查看了一下，发现日志文件的第一组终于增加了一个副本。
```shell
SQL> select group#,member from v$logfile;

    GROUP#
----------
MEMBER
--------------------------------------------------------------------------------
         3
/u01/app/oracle/oradata/orcl/redo03.log

         2
/u01/app/oracle/oradata/orcl/redo02.log

         1
/u01/app/oracle/oradata/orcl/redo01.log


    GROUP#
----------
MEMBER
--------------------------------------------------------------------------------
         1
/u01/app/oracle/oradata/orcl/redo01_2.log


SQL> 

```
- 控制文件复用
  查看现有的控制文件。
```shell
SQL> select name from v$controlfile
  2  ;

NAME
--------------------------------------------------------------------------------
/u01/app/oracle/oradata/orcl/control01.ctl
/u01/app/oracle/flash_recovery_area/orcl/control02.ctl

SQL> 
```
我很看到了两个，其实已经有复用了。我们再添加一个逻辑上的控制文件。然后关闭数据库并退出，在物理空间上也设定一个控制文件。然后再启动就可以了。
```shell
SQL> alter system set control_files='/u01/app/oracle/oradata/orcl/control01.ctl','/u01/app/oracle/flash_recovery_area/orcl/control02.ctl','/u01/app/oracle/oradata/orcl/control03.ctl' scope=spfile;

System altered.

SQL> shutdown immidiatly
SP2-0717: illegal SHUTDOWN option
SQL> shutdown immediate;
Database closed.
Database dismounted.
ORACLE instance shut down.
SQL>   1* alter system set control_files='/u01/app/oracle/oradata/orcl/control01.ctl','/u01/app/oracle/flash_recovery_area/orcl/control02.ctl','/u01/app/oracle/oradata/orcl/control03.ctl' scope=spfile
SQL> exit    
Disconnected from Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options
[oracle@dbs33 ~]$ cp /u01/app/oracle/oradata/orcl/control01.ctl /u01/app/oracle/oradata/orcl/control03.ctl
[oracle@dbs33 ~]$ sqlplus / as sysdba

SQL*Plus: Release 11.2.0.1.0 Production on Tue Mar 14 15:56:12 2017

Copyright (c) 1982, 2009, Oracle.  All rights reserved.

Connected to an idle instance.

SQL> startup
ORACLE instance started.

Total System Global Area  849530880 bytes
Fixed Size                  1339824 bytes
Variable Size             515903056 bytes
Database Buffers          327155712 bytes
Redo Buffers                5132288 bytes
Database mounted.
Database opened.
SQL> 
```
###3.9、备份工具 recover manager
####3.9.1、创建日志归档
我们首先先备份一下日志，创建一个备份目录，存放日志归档：
```shell
[root@dbs33 ~]# mkdir -p /u01/arch01
[root@dbs33 ~]# 
```
然后我们创建备份目录，重启。
```shell
SQL> alter system set log_archive_dest_1='location=/u01/arch01';

System altered.

SQL> shutdown immediate;
Database closed.
Database dismounted.
ORACLE instance shut down.
SQL> startup mount
ORACLE instance started.

Total System Global Area  849530880 bytes
Fixed Size                  1339824 bytes
Variable Size             515903056 bytes
Database Buffers          327155712 bytes
Redo Buffers                5132288 bytes
Database mounted.
SQL> alter database archivelog;

Database altered.

SQL> alter database open;

Database altered.

SQL> 
```
####3.9.2、数据文件备份
下文展现了各种不同程度的备份，在RMAN>之后写明了所有的数据库备份，在命令的输出部分我们可以看大备份的位置：
```shell
[root@dbs33 ~]# su - oracle
[oracle@dbs33 ~]$ rman target /

Recovery Manager: Release 11.2.0.1.0 - Production on Tue Mar 14 16:25:40 2017

Copyright (c) 1982, 2009, Oracle and/or its affiliates.  All rights reserved.

connected to target database: ORCL (DBID=1465463568)

RMAN> backup spfile;

Starting backup at 14-MAR-17
using target database control file instead of recovery catalog
allocated channel: ORA_DISK_1
channel ORA_DISK_1: SID=36 device type=DISK
channel ORA_DISK_1: starting full datafile backup set
channel ORA_DISK_1: specifying datafile(s) in backup set
including current SPFILE in backup set
channel ORA_DISK_1: starting piece 1 at 14-MAR-17
channel ORA_DISK_1: finished piece 1 at 14-MAR-17
piece handle=/u01/app/oracle/flash_recovery_area/ORCL/backupset/2017_03_14/o1_mf_nnsnf_TAG20170314T162615_ddhb97hw_.bkp tag=TAG20170314T162615 comment=NONE
channel ORA_DISK_1: backup set complete, elapsed time: 00:00:01
Finished backup at 14-MAR-17

RMAN> backup current controlfile;

Starting backup at 14-MAR-17
using channel ORA_DISK_1
channel ORA_DISK_1: starting full datafile backup set
channel ORA_DISK_1: specifying datafile(s) in backup set
including current control file in backup set
channel ORA_DISK_1: starting piece 1 at 14-MAR-17
channel ORA_DISK_1: finished piece 1 at 14-MAR-17
piece handle=/u01/app/oracle/flash_recovery_area/ORCL/backupset/2017_03_14/o1_mf_ncnnf_TAG20170314T162633_ddhb9toc_.bkp tag=TAG20170314T162633 comment=NONE
channel ORA_DISK_1: backup set complete, elapsed time: 00:00:01
Finished backup at 14-MAR-17

RMAN> backup datafile '/u01/app/oracle/oradata/orcl/users01.dbf';

Starting backup at 14-MAR-17
using channel ORA_DISK_1
channel ORA_DISK_1: starting full datafile backup set
channel ORA_DISK_1: specifying datafile(s) in backup set
input datafile file number=00004 name=/u01/app/oracle/oradata/orcl/users01.dbf
channel ORA_DISK_1: starting piece 1 at 14-MAR-17
channel ORA_DISK_1: finished piece 1 at 14-MAR-17
piece handle=/u01/app/oracle/flash_recovery_area/ORCL/backupset/2017_03_14/o1_mf_nnndf_TAG20170314T162723_ddhbccxm_.bkp tag=TAG20170314T162723 comment=NONE
channel ORA_DISK_1: backup set complete, elapsed time: 00:00:01
Finished backup at 14-MAR-17

RMAN> backup tablespace users,example;

Starting backup at 14-MAR-17
using channel ORA_DISK_1
channel ORA_DISK_1: starting full datafile backup set
channel ORA_DISK_1: specifying datafile(s) in backup set
input datafile file number=00005 name=/u01/app/oracle/oradata/orcl/example01.dbf
input datafile file number=00004 name=/u01/app/oracle/oradata/orcl/users01.dbf
channel ORA_DISK_1: starting piece 1 at 14-MAR-17
channel ORA_DISK_1: finished piece 1 at 14-MAR-17
piece handle=/u01/app/oracle/flash_recovery_area/ORCL/backupset/2017_03_14/o1_mf_nnndf_TAG20170314T162759_ddhbdhjv_.bkp tag=TAG20170314T162759 comment=NONE
channel ORA_DISK_1: backup set complete, elapsed time: 00:00:03
Finished backup at 14-MAR-17

RMAN> backup database;

Starting backup at 14-MAR-17
using channel ORA_DISK_1
channel ORA_DISK_1: starting full datafile backup set
channel ORA_DISK_1: specifying datafile(s) in backup set
input datafile file number=00001 name=/u01/app/oracle/oradata/orcl/system01.dbf
input datafile file number=00002 name=/u01/app/oracle/oradata/orcl/sysaux01.dbf
input datafile file number=00003 name=/u01/app/oracle/oradata/orcl/undotbs01.dbf
input datafile file number=00005 name=/u01/app/oracle/oradata/orcl/example01.dbf
input datafile file number=00006 name=/u01/app/oracle/oradata/orcl/tbs1_1.dbf
input datafile file number=00007 name=/u01/app/oracle/oradata/orcl/tbs1_2.dbf
input datafile file number=00004 name=/u01/app/oracle/oradata/orcl/users01.dbf
channel ORA_DISK_1: starting piece 1 at 14-MAR-17
channel ORA_DISK_1: finished piece 1 at 14-MAR-17
piece handle=/u01/app/oracle/flash_recovery_area/ORCL/backupset/2017_03_14/o1_mf_nnndf_TAG20170314T162839_ddhbfqm2_.bkp tag=TAG20170314T162839 comment=NONE
channel ORA_DISK_1: backup set complete, elapsed time: 00:00:26
channel ORA_DISK_1: starting full datafile backup set
channel ORA_DISK_1: specifying datafile(s) in backup set
including current control file in backup set
including current SPFILE in backup set
channel ORA_DISK_1: starting piece 1 at 14-MAR-17
channel ORA_DISK_1: finished piece 1 at 14-MAR-17
piece handle=/u01/app/oracle/flash_recovery_area/ORCL/backupset/2017_03_14/o1_mf_ncsnf_TAG20170314T162839_ddhbglwo_.bkp tag=TAG20170314T162839 comment=NONE
channel ORA_DISK_1: backup set complete, elapsed time: 00:00:01
Finished backup at 14-MAR-17

RMAN> backup archivelog all;

Starting backup at 14-MAR-17
ORACLE error from target database: 
ORA-16014: log 2 sequence# 8 not archived, no available destinations
ORA-00312: online log 2 thread 1: '/u01/app/oracle/oradata/orcl/redo02.log'

using channel ORA_DISK_1
specification does not match any archived log in the repository
backup cancelled because there are no files to backup
Finished backup at 14-MAR-17

RMAN> 
```
####3.9.3、介质损坏
- 个别控制文件损坏
  我们模拟出这个场景，首先让设定文件损坏：
```shell
[oracle@dbs33 ~]$ rm /u01/app/oracle/oradata/orcl/control03.ctl
[oracle@dbs33 ~]$ rm /u01/app/oracle/flash_recovery_area/orcl/control02.ctl
[oracle@dbs33 ~]$ 
```
这个时候我们强制关机，然后开启，发现出现了error
```shell
SQL> Shutdown abort
ORACLE instance shut down.
SQL> Startup
ORACLE instance started.

Total System Global Area  849530880 bytes
Fixed Size                  1339824 bytes
Variable Size             515903056 bytes
Database Buffers          327155712 bytes
Redo Buffers                5132288 bytes
ORA-00205: error in identifying control file, check alert log for more info


SQL> 
```
然后我们做一下恢复
```shell
[oracle@dbs33 ~]$ cp /u01/app/oracle/oradata/orcl/control01.ctl /u01/app/oracle/oradata/orcl/control03.ctl
[oracle@dbs33 ~]$ cp /u01/app/oracle/oradata/orcl/control01.ctl  /u01/app/oracle/flash_recovery_area/orcl/control02.ctl
[oracle@dbs33 ~]$ 
```
然后我们就发现可以正常打开了，接着之前的输入：
```shell
SQL> alter database mount;

Database altered.

SQL> alter database open;

Database altered.

SQL> 
```
- 存储控制文件的介质损坏
  我们可以使用和前一种损坏的相似方法重新指定控制文件。
```shell
SQL> Alter system set control_files='/u01/app/oracle/oradata/orcl/control01.ctl' scope=spfile;

System altered.

SQL> 
```
- 个别日志文件损坏
  我们删除对应的日志文件来模拟这个场景：
```shell
[oracle@dbs33 ~]$ rm /u01/app/oracle/oradata/orcl/redo01.log
[oracle@dbs33 ~]$ rm /u01/app/oracle/oradata/orcl/redo02.log
[oracle@dbs33 ~]$ rm /u01/app/oracle/oradata/orcl/redo03.log
```
这个时候数据库会正常运行，但是我们查看不了日志了。
为了处理这个问题，首先我们要在数据库上把逻辑的成员删除了。
如果直接删除是没有办法的，我们需要先切换当前的日志文件：`alter system switch logfile`
```shell
Alter database drop logfile member  ‘/u01/app/oracle/oradata/orcl/redo01.log’;
Alter database drop logfile member  ‘/u01/app/oracle/oradata/orcl/redo02.log’;
Alter database drop logfile member  ‘/u01/app/oracle/oradata/orcl/redo03.log’;
```
然后我们再次复用：
```shell
Alter database add logfile member ‘/u01/app/oracle/oradata/orcl/redo01.log’ to group1;
Alter database add logfile member ‘/u01/app/oracle/oradata/orcl/redo02.log’ to group2;
Alter database add logfile member ‘/u01/app/oracle/oradata/orcl/redo03.log’ to group3;
```

####3.9.4、介质损坏---非关键数据文件损坏
删除了部分数据文件之后，我们还是可以查询到删除的数据文件包含的记录。那是因为之前的数据可能放到了内存中，清空内存来彻底删除。
服务器不会宕机。
使用RMAN进行恢复。
首先我们启动数据库：
```shell
SQL> startup;
ORACLE instance started.

Total System Global Area  849530880 bytes
Fixed Size	    1339824 bytes
Variable Size	  520097360 bytes
Database Buffers	  322961408 bytes
Redo Buffers	    5132288 bytes
Database mounted.
ORA-01157: cannot identify/lock data file 4 - see DBWR trace file
ORA-01110: data file 4: '/u01/app/oracle/oradata/orcl/users01.dbf'
```
然后我们让一些文件离线，并且恢复。
```shell
RMAN> sql' alter database datafile 4,5 offline';

sql statement:  alter database datafile 4,5 offline

RMAN> restore datafile 4,5;

Starting restore at 17-MAR-17
allocated channel: ORA_DISK_1
channel ORA_DISK_1: SID=17 device type=DISK

channel ORA_DISK_1: starting datafile backup set restore
channel ORA_DISK_1: specifying datafile(s) to restore from backup set
channel ORA_DISK_1: restoring datafile 00004 to /u01/app/oracle/oradata/orcl/users01.dbf
channel ORA_DISK_1: restoring datafile 00005 to /u01/app/oracle/oradata/orcl/example01.dbf
channel ORA_DISK_1: reading from backup piece /u01/app/oracle/flash_recovery_area/ORCL/backupset/2017_03_14/o1_mf_nnndf_TAG20170314T163426_ddhbrlb2_.bkp
channel ORA_DISK_1: piece handle=/u01/app/oracle/flash_recovery_area/ORCL/backupset/2017_03_14/o1_mf_nnndf_TAG20170314T163426_ddhbrlb2_.bkp tag=TAG20170314T163426
channel ORA_DISK_1: restored backup piece 1
channel ORA_DISK_1: restore complete, elapsed time: 00:00:03
Finished restore at 17-MAR-17

RMAN> recover datafile 4,5;

Starting recover at 17-MAR-17
using channel ORA_DISK_1

starting media recovery
media recovery complete, elapsed time: 00:00:00

Finished recover at 17-MAR-17

RMAN> sql 'alter database datafile 4,5 online';

sql statement: alter database datafile 4,5 online

RMAN> 
```
####3.9.5、介质损坏---关键数据文件损坏
系统会宕机。我们模拟这个过程。首先删除关键数据文件。
```shell
[root@dbs33 ~]# rm /u01/app/oracle/oradata/orcl/example01.dbf y
rm: remove regular file `/u01/app/oracle/oradata/orcl/example01.dbf'? y
[root@dbs33 ~]# rm /u01/app/oracle/oradata/orcl/users01.dbf 
rm: remove regular file `/u01/app/oracle/oradata/orcl/users01.dbf'? y
[root@dbs33 ~]# rm /u01/app/oracle/oradata/orcl/undotbs01.dbf 
rm: remove regular file `/u01/app/oracle/oradata/orcl/undotbs01.dbf'? y
[root@dbs33 ~]# rm /u01/app/oracle/oradata/orcl/sysaux01.dbf 
rm: remove regular file `/u01/app/oracle/oradata/orcl/sysaux01.dbf'? y
[root@dbs33 ~]# rm /u01/app/oracle/oradata/orcl/system01.dbf
rm: remove regular file `/u01/app/oracle/oradata/orcl/system01.dbf'? y```
然后让服务器断电模拟宕机过程。
​```shell
SQL> shutdown abort;
ORACLE instance shut down.
SQL> 
```
然后在启动的时候就出现了出错
```shell
SQL> startup 
ORACLE instance started.

Total System Global Area  849530880 bytes
Fixed Size	    1339824 bytes
Variable Size	  520097360 bytes
Database Buffers	  322961408 bytes
Redo Buffers	    5132288 bytes
Database mounted.
ORA-01157: cannot identify/lock data file 1 - see DBWR trace file
ORA-01110: data file 1: '/u01/app/oracle/oradata/orcl/system01.dbf'


SQL> 
```
然后我们是reman来恢复数据文件。
```shell
RMAN> restore database;

Starting restore at 17-MAR-17
using target database control file instead of recovery catalog
allocated channel: ORA_DISK_1
channel ORA_DISK_1: SID=17 device type=DISK

channel ORA_DISK_1: starting datafile backup set restore
channel ORA_DISK_1: specifying datafile(s) to restore from backup set
channel ORA_DISK_1: restoring datafile 00001 to /u01/app/oracle/oradata/orcl/system01.dbf
channel ORA_DISK_1: restoring datafile 00002 to /u01/app/oracle/oradata/orcl/sysaux01.dbf
channel ORA_DISK_1: restoring datafile 00003 to /u01/app/oracle/oradata/orcl/undotbs01.dbf
channel ORA_DISK_1: reading from backup piece /u01/app/oracle/flash_recovery_area/ORCL/backupset/2017_03_14/o1_mf_nnndf_TAG20170314T162910_ddhbgq37_.bkp
channel ORA_DISK_1: piece handle=/u01/app/oracle/flash_recovery_area/ORCL/backupset/2017_03_14/o1_mf_nnndf_TAG20170314T162910_ddhbgq37_.bkp tag=TAG20170314T162910
channel ORA_DISK_1: restored backup piece 1
channel ORA_DISK_1: restore complete, elapsed time: 00:00:15
channel ORA_DISK_1: starting datafile backup set restore
channel ORA_DISK_1: specifying datafile(s) to restore from backup set
channel ORA_DISK_1: restoring datafile 00004 to /u01/app/oracle/oradata/orcl/users01.dbf
channel ORA_DISK_1: restoring datafile 00005 to /u01/app/oracle/oradata/orcl/example01.dbf
channel ORA_DISK_1: reading from backup piece /u01/app/oracle/flash_recovery_area/ORCL/backupset/2017_03_14/o1_mf_nnndf_TAG20170314T163426_ddhbrlb2_.bkp
channel ORA_DISK_1: piece handle=/u01/app/oracle/flash_recovery_area/ORCL/backupset/2017_03_14/o1_mf_nnndf_TAG20170314T163426_ddhbrlb2_.bkp tag=TAG20170314T163426
channel ORA_DISK_1: restored backup piece 1
channel ORA_DISK_1: restore complete, elapsed time: 00:00:01
Finished restore at 17-MAR-17

RMAN> recover database;

Starting recover at 17-MAR-17
using channel ORA_DISK_1

starting media recovery
media recovery complete, elapsed time: 00:00:01

Finished recover at 17-MAR-17

RMAN> 
```
####3.9.6、介质损坏---临时文件损坏
因为临时文件是没有备份的。
首先我们添加一个临时文件。
```shell
SQL> Alter tablespace temp add tempfile '/u01/app/oracle/oradata/orcl/temp02.dbf' size 50M autoextend on;

Tablespace altered.

SQL> 
```
从物理和逻辑上删除被破坏的临时文件。
```shell
SQL> select name from v$tempfile;

NAME
--------------------------------------------------------------------------------
/u01/app/oracle/oradata/orcl/temp01.dbf
SQL> Alter tablespace temp drop tempfile '/u01/app/oracle/oradata/orcl/temp01.dbf';

Tablespace altered.

SQL> 
```
```shell
[root@dbs33 ~]# rm /u01/app/oracle/oradata/orcl/temp01.dbf
rm: remove regular file `/u01/app/oracle/oradata/orcl/temp01.dbf'? y
```

还有一种场景，数据库关闭期间丢失的临时文件，启动服务器的时候会自动创建。

####3.9.7、介质损坏---口令文件损坏
我们删除口令文件：
```shell
[root@dbs33 ~]# rm /u01/app/oracle/product/11.2.0/dbhome_1/dbs/orapworcl
rm: remove regular file `/u01/app/oracle/product/11.2.0/dbhome_1/dbs/orapworcl'? y
[root@dbs33 ~]# 
```
开启监听器：
```shell
[oracle@dbs33 ~]$ lsnrctl start

LSNRCTL for Linux: Version 11.2.0.1.0 - Production on 17-MAR-2017 10:11:40

Copyright (c) 1991, 2009, Oracle.  All rights reserved.

Starting /u01/app/oracle/product/11.2.0/dbhome_1/bin/tnslsnr: please wait...

TNSLSNR for Linux: Version 11.2.0.1.0 - Production
System parameter file is /u01/app/oracle/product/11.2.0/dbhome_1/network/admin/listener.ora
Log messages written to /u01/app/oracle/diag/tnslsnr/dbs33/listener/alert/log.xml
Listening on: (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=dbs33.example.com)(PORT=1521)))

Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=dbs33.example.com)(PORT=1521)))
STATUS of the LISTENER
------------------------
Alias                     LISTENER
Version                   TNSLSNR for Linux: Version 11.2.0.1.0 - Production
Start Date                17-MAR-2017 10:11:40
Uptime                    0 days 0 hr. 0 min. 0 sec
Trace Level               off
Security                  ON: Local OS Authentication
SNMP                      OFF
Listener Parameter File   /u01/app/oracle/product/11.2.0/dbhome_1/network/admin/listener.ora
Listener Log File         /u01/app/oracle/diag/tnslsnr/dbs33/listener/alert/log.xml
Listening Endpoints Summary...
  (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=dbs33.example.com)(PORT=1521)))
The listener supports no services
The command completed successfully
```
开启数据库：
```shell
SQL> startup;
ORACLE instance started.

Total System Global Area  849530880 bytes
Fixed Size	    1339824 bytes
Variable Size	  520097360 bytes
Database Buffers	  322961408 bytes
Redo Buffers	    5132288 bytes
Database mounted.
Database opened.
SQL> 
```
远程登录：
```shell
[oracle@dbs33 ~]$ sqlplus sys/oracle_4U@orcl as sysdba;

SQL*Plus: Release 11.2.0.1.0 Production on Fri Mar 17 10:12:01 2017

Copyright (c) 1982, 2009, Oracle.  All rights reserved.

ERROR:
ORA-01031: insufficient privileges


Enter user-name: 
```
我们发现远程登录失败了。
我们重建口令。只要重新注册密码就好了。
```shell
[oracle@dbs33 ~]$ orapwd file=/u01/app/oracle/product/11.2.0/dbhome_1/dbs/orapworcl password=oracle_4U
[oracle@dbs33 ~]$ 
```
之后发现就可以重新登录了：
```shell
[oracle@dbs33 ~]$ sqlplus sys/oracle_4U@orcl as sysdba;

SQL*Plus: Release 11.2.0.1.0 Production on Fri Mar 17 10:16:59 2017

Copyright (c) 1982, 2009, Oracle.  All rights reserved.


Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

SQL> 
```
###3.10、闪回数据库
####3.10.1、误操作---DROP
回收站recycle bin.
参数show parameter recyclebin
system表空间的表删除-------直接删除
下面做测试，我们在system和users表空间中各创造一个表，然后删除，查看回收站。
```shell
SQL> create table test001 tablespace system as select * from dba_objects;

Table created.

SQL> create table test002 tablespace users as select * from dba_objects;

Table created.

SQL> drop table test001;

Table dropped.

SQL> drop table test002;

Table dropped.

SQL> show recyclebin;
ORIGINAL NAME	RECYCLEBIN NAME	OBJECT TYPE  DROP TIME
---------------- ------------------------------ ------------ -------------------
TEST002 	BIN$SuPs/bfWuBHgUAB/AQAbTA==$0 TABLE	    2017-03-17:10:27:57
SQL> 
```
其实实际上表并没有动，只是表的名称被改变成BIN$SuPs/bfWuBHgUAB/AQAbTA==$0 TABLE了。
恢复方法很多。通过flash back来恢复。
```shell
SQL> flashback table test002 to before drop;

Flashback complete.

SQL> 
```
回收站占用的是原来表空间的存储位置，如果表空间不够用了，那么就是自动清除这个表。
当然我们也可以使用purge命令直接删除。
```shell
SQL> drop table test002;

Table dropped.

SQL> show recyclebin;
ORIGINAL NAME	RECYCLEBIN NAME	OBJECT TYPE  DROP TIME
---------------- ------------------------------ ------------ -------------------
TEST002 	BIN$SuPs/bfXuBHgUAB/AQAbTA==$0 TABLE	    2017-03-17:10:40:06
SQL> purge table TEST002;

Table purged.

SQL> show recyclebin;
SQL> 
```
####3.10.2、闪回查询与闪回更改
主要对付DML语句。
如果已经未提交（commit），那就可以回滚。
如果还没有提交（commit），那就闪回查询。可以查看某个时间点的所有数据。需要开启行移动。
####3.10.3、闪回数据库
开启闪回数据库功能。
```shell
//挂载数据库
SQL> startup mount;
ORACLE instance started.

Total System Global Area  849530880 bytes
Fixed Size	    1339824 bytes
Variable Size	  520097360 bytes
Database Buffers	  322961408 bytes
Redo Buffers	    5132288 bytes
Database mounted.
//开启闪回
SQL> alter database flashback on;

Database altered.
//开启数据库
SQL> alter database open;

Database altered.
//查看闪回参数
SQL> show parameter db_flashback;

NAME	    TYPE	VALUE
------------------------------------ ----------- ------------------------------
db_flashback_retention_target	    integer	1440
//设置闪回时间
SQL> alter system set db_flashback_retention_target=2880;

System altered.
//查看闪回是不是开启了
SQL> select flashback_on from v$database;

FLASHBACK_ON
------------------
YES

SQL> 
```

##3、Mysql系统管理
###3.1、Mysql的服务器分发
####3.1.1、源代码
最新代码，立即可用，自编译
原码安装需要很多的
依赖，比如cmake，perl，编译器等等。
```python
[root@dbs15 mysql]# tar zxf /root/mysql-5.6.10.tar.gz 
[root@dbs15 mysql]# cd mysql-5.6.10/
[root@dbs15 mysql-5.6.10]# ls
BUILD            dbug                 libmysqld    regex          unittest
BUILD-CMAKE      Docs                 libservices  scripts        VERSION
client           Doxyfile-perfschema  man          sql            vio
cmake            extra                mysql-test   sql-bench      win
CMakeLists.txt   include              mysys        sql-common     zlib
cmd-line-utils   INSTALL-SOURCE       mysys_ssl    storage
config.h.cmake   INSTALL-WIN-SOURCE   packaging    strings
configure.cmake  libevent             plugin       support-files
COPYING          libmysql             README       tests
[root@dbs15 mysql-5.6.10]# pwd
/tmp/mysql/mysql-5.6.10
[root@dbs15 mysql-5.6.10]# rpm -q cmake gcc-c++ perl
package cmake is not installed
package gcc-c++ is not installed
perl-5.10.1-129.el6.x86_64
[root@dbs15 mysql-5.6.10]# ls 
```
然后我们安装一下光盘中的软件包。cmake可以安装，但是gcc不可以。
更新yum源。主要是将dev底下的光盘放在mut目录下。
然后就可以进行编译了。
然后在mysql原码目录下创建bld文件夹，在文件夹中输入`cmake ..`就可以进行cmake了。
之后还在这个目录下执行make，这样子程序就编译好了。

然后make install。

mysql会被默认安装在/usr/local/mysql目录下。

然后我们需要设定这个目录的权限。
然后初始化数据库（在二进制包安装里面有讲）。
设定启动脚本。
然后启动mysql服务就好了。



####3.1.2、二进制包
预先编译好的。不包括依赖。
我们需要先删除之前已经有的RPM安装方式的mysql。首先关闭mysql。然后删除所有mysql相关的东西。
然后关闭虚拟机，照一个快照。
然后我们就是我们需要下载二进制码至root目录。
然后是删除在安装过程中所建立的账号。
然后我就我们把二进制直接拷进来。我们建议将程序文件放在/usr/local/mysql目录中，这个就是我们的工作目录。
```shell
[root@dbs15 Desktop]# cd /usr/local/
[root@dbs15 local]# tar zxf /root/mysql-5.6.10-linux-glibc2.5-x86_64.tar.gz
[root@dbs15 local]# ln -s /usr/local/mysql-5.6.10-linux-glibc2.5-x86_64/ /usr/local/mysql
[root@dbs15 local]# ls
bin  games    lib    libexec  mysql-5.6.10-linux-glibc2.5-x86_64  share
etc  include  lib64  mysql    sbin                                src
[root@dbs15 local]# 
```
然后我们更改文件拥有者，因为现在这个目录是属于root的。
```shell
[root@dbs15 local]# groupadd mysql
[root@dbs15 local]# useradd -r -g mysql -s /bin/false mysql
[root@dbs15 local]# cd /usr/local/mysql
[root@dbs15 mysql]# chown -R root.mysql .
[root@dbs15 mysql]# chown -R mysql.mysql data
```
然后我们设置启动脚本
```shell
[root@dbs15 mysql]# cp /usr/local/mysql/support-files/mysqld_multi.server /etc/init.d/mysqld_multi
[root@dbs15 mysql]# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql
[root@dbs15 mysql]# chkconfig --add mysql
[root@dbs15 mysql]# chkconfig --add mysqld_multi

[root@dbs15 mysql]# 

```
然后我们初始化数据库。
服务账号 --user=mysql
程序目录 --basedir =/usr/local/mysql
数据目录 --datadir=/usr/local/mysql/data
我们通过执行下列命令来初始化mysql。
```shell
[root@dbs15 mysql]# /usr/local/mysql/scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data
```
然后我们打开mysql
```shell
[root@dbs15 mysql]# service mysql start
Starting MySQL. SUCCESS! 
[root@dbs15 mysql]# 
```
然后我们登录
```shell
[root@dbs15 mysql]# /usr/local/mysql/bin/mysqladmin -uroot password 'oracle'
[root@dbs15 mysql]# 
```
配置多个Mysql服务器。
####3.1.3、RPM安装。


###3.2、Mysql服务器的管理与配置
（三种添加服务器配置的方式）在编译的时候加入特性。在编译的时候可以加入编译选项和编译参数。
第二种途径就是使用服务器配置文件，有若干个，主要是/etc/my.cnf。系统启动的时候会读这个参数的内容。
配置信息还可以在不同的配置文件中，还有/etc/mysql/my.cnf，等等。
第三种方式是带参数启动。我们使用mysqld_safe启动。service-》mysqld_safe-》mysqld。
两种关闭方式：service mysql stop或者mysqladmin shutdown
在my.cnf可以预先写上某一个二进制文件的命令行参数。所以说实际上在my.cnf中写配置和在启动一个二进制文件时候加命令行参数是一样的。
我们可以执行sql语句->show variables like。。。。来查看这些参数。

###3.3、开启及设置日志文件
Mysql的日志文件
- 错误 --log-error（在命令中使用）
  mysql_safe --user=mysql --log-error ???&
  但是我们可以写在配置文件中，来防止每一次都要写命令。
  我们在配置文件中，写log-error和log_error都可以。
  我们要在mysqld_safe上面加一个参数。保证开启的时候启动日志文件。
  这个参数会定义一个默认的错误日志的位置，但是我们也可以通过定义log_error="错误日志路径名"来定义我们自定义的错误日志。

- 常规查询日志 --general_log
  常规日志是跟着服务器来的，我们只要在my.cnf的[mysqld]加入general_log = 1，以及general_log_file = "日志路径名"。（一个服务器对应着一个mysqld嘛）
  这个日志记录的是我们的常规操作。

- 慢速查询日志 --slow varibles like 'slow_query_log%'可以查看
  我们在mysqld中设定slow_query_log=1（开启查询），slow_query_log_file="日志文件路径" long_query_time=3（将3秒以上的查询规定为慢查询）

- 二进制日志 log_bin
  log_bin=1
  此外我们还可以看是基于行还是基于语句的，基于行的日志会更加精确。
  binlog_format=ROW
  记录数据定义语言和数据控制语言。二进制日志记载数据库变化过程。主要的作用就是用在主从系统中，我们可以实现主从备份和读写分离。这个日志长得和常规查询日志很像。

- 审计日志

