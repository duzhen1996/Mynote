- 直接运行Python程序
- print语句的规则，以及逗号的意义
- raw_input输入
- 整数与16进制的0x前缀
- 使用''与""的字符串以及转义字符。r""与r''的默认不转义。使用'''.....'''打印多行内容
- 整数除法与浮点数除法
- ASC码、Unicode与UTF-8的区别。encode（要转化成的字符编码），decode（要转化成Unicode的目标代码）
- List，正负索引，List嵌套List。Tuple不可变，逗号初始化与小括号区分
- 条件、循环while、以及for遍历List和元组
- 字典、set([])非重复元素
- 常用函数与数据类型转换，函数对象的赋值与引用
- isinstance，类型检查，可以用于函数参数类型检查
  -函数多个返回值，实为一个元祖
- 默认参数不能变，指向不可变对象，他是一个在函数调用的时候产生的隐式声明的变量。如果必须指向可变对象，就把他搞成None，在函数体里面设为其他可变的东西。
- *参数传tuple，**参数传键值对。可以在声明和调用的时候使用。
> Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。
> 默认参数一定要用不可变对象，如果是可变对象，运行会有逻辑错误！
> 要注意定义可变参数和关键字参数的语法：
> *args是可变参数，args接收的是一个tuple；
> **kw是关键字参数，kw接收的是一个dict。
> 以及调用函数时如何传入可变参数和关键字参数的语法：
> 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；
> 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。
> 使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。

- 切片，可以直接从一个list钟取出一段数据。是一个左闭右开区间。我们对List、元组、字符串都能做切片操作。核心语法[::]

- 迭代，Python使用for来进行迭代操作，和Java差异很大，没有哨兵变量。并且可以使用collections 的Iterable以及类型检查来看一个东西是不是可以迭代的。
- 列表生成式，这个是一个代码简洁但是可读性一般的东西，主要特点就是在一个语句外面套了一层中括号。[运算 for... if...][运算 for... for...]
- 列表生成器，和列表生成试相比就是把外层的中括号换成小括号。并且提供一个next函数，这个函数的意义就是不断获取生成的列表的下一个值。这个东西的好处在于，实际上列表并没有存在，只是这个生成会不断根据我们在生成器中给出的算法不断生成“列表的下一个值”。并且生成器是可以使用for迭代的。此外使用yield，函数逻辑也可以成为生成器对象，当函数执行到yield的时候停止执行，并且范围yield之后的值，当再次调用这个函数（生成器）的时候函数接着yield之后的值运行。
  -函数式编程。在Python中，函数也是也是一种变量，一个函数名也可以进行赋值、被赋值、作为其他函数的形参等操作。
- map/reduce。这是一个在hadoop中让我云里雾里的概念，但是在python中其实也有这两个东西，我已经明白了。一个是同时为List中每一个元素做一个操作，还有一个是将list中每一个元素安装一定的策略滚起来。
- 在Python中，函数也可以作为其他函数的返回值。并且这种在函数中定义的函数可以直接使用母函数中的局部变量。但是因为不会立即运行，所以如果这个局部变量在之后的代码中可能会改变，那么我们就要再包一层函数。这样子就正常了。
> 以这一节的例子来看，闭包中应该只包含变量i的地址，告诉程序当他被调用时这个i应该从哪里找，此时并不涉及i的值。只有当真正调用时，才根据此时i的值算出最终结果，而此时在返回3个函数之后，i的值已经成为3了，所以当我们开始调用函数时，返回的值就都是9了.
```Python
def count():
     fs = []
     for i in range(1, 4):
         def f(j):
             def g():
                 return j*j
             return g
         fs.append(f(i))
     return fs
f1, f2, f3 = count()
print f1()
```


- Python使用lambda调用匿名函数，Python作为匿名函数很有意思。主要就是lambda 函数形参：表达式返回值。

- Python存在装饰器，在函数的声明上面增加一个@装饰函数名相当于执行语句：目标函数=装饰函数（目标函数）。目标函数在装饰函数中执行并返回值。这个比较难以理解，我们现在举个例子:
```Python
import functools



#写一个装饰器函数，打印语句
def log(text):
    def deca(function):
        #这里又有一个装饰器，把wrapper的函数签名改掉
        @functools.wraps(function)
        def wrapper(*args , **kwargs):
            print "函数运行了！text =",text
            returnvalue = function(*args , **kwargs)
            print "函数结束了！"
            return returnvalue
        return wrapper
    return deca;

# 写一个可以被装饰的函数
#我们可以看到，这个@log的意义等效于在函数调用之前执行一个函数的赋值语句
#这个赋值语句就是把wrapper先给goalFun。首先log("测试文字")先返回deca，之后还有一个括号
#即是调用deca(goalFun)，这个东西返回的是wrapper，这个东西之后会赋给goalFun。
#所以我们调用goalFun（），实际上调用了wrapper（）。当然，我们使用functools提供的工具
#改变了wrapper的函数签名
#@log("测试文字")
def goalFun():
    print "调用了goalFun"

goalFun = log("测试文字")(goalFun)
goalFun();
```

